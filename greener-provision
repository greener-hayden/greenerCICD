#!/bin/bash

# Greener CI/CD CLI Provisioning Tool
# Provisions CI/CD secrets to repositories via Cloudflare Worker

set -euo pipefail

# Configuration
WORKER_URL="https://greener-cicd-webhook-proxy.workers.dev"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# CLI metadata
VERSION="0.5.0"
CLI_NAME="greener-provision"
HOMEPAGE="https://github.com/greener-hayden/greenerCICD"

# Exit codes
EXIT_OK=0
EXIT_UNKNOWN=1
EXIT_BAD_ARGS=2
EXIT_PREREQ=3
EXIT_AUTH=4
EXIT_PERM=5
EXIT_NOT_FOUND=6
EXIT_RATE_LIMIT=7
EXIT_NETWORK=8
EXIT_PARTIAL=10

# Detect OS and terminal environment
detect_os() {
  case "$(uname -s 2>/dev/null || echo 'Unknown')" in
    Darwin*) echo "macos" ;;
    Linux*) echo "linux" ;;
    MINGW*|MSYS*|CYGWIN*) echo "windows" ;;
    *) echo "unknown" ;;
  esac
}

OS_TYPE=$(detect_os)

# Terminal capability detection
UI_MODE="auto"  # auto|rich|minimal|ci
SUPPORTS_UNICODE=false
SUPPORTS_ANSI=false
IS_INTERACTIVE=false

detect_terminal_capabilities() {
  # Check if running in CI environment
  if [[ -n "${CI:-}" ]] || [[ -n "${CONTINUOUS_INTEGRATION:-}" ]] || 
     [[ -n "${GITHUB_ACTIONS:-}" ]] || [[ -n "${JENKINS_URL:-}" ]] || 
     [[ -n "${TRAVIS:-}" ]] || [[ -n "${CIRCLECI:-}" ]] || 
     [[ -n "${GITLAB_CI:-}" ]] || [[ -n "${BUILDKITE:-}" ]];
  then
    UI_MODE="ci"
    return
  fi

  # Check if terminal is interactive
  if [[ -t 0 && -t 1 ]]; then
    IS_INTERACTIVE=true
  fi

  # Check for ANSI color support
  if [[ -n "${NO_COLOR:-}" ]] || [[ "${TERM:-}" == "dumb" ]] || [[ ! -t 1 ]]; then
    SUPPORTS_ANSI=false
  else
    SUPPORTS_ANSI=true
  fi

  # Check Unicode support
  if [[ "${LANG:-}" == *"UTF-8"* ]] || [[ "${LC_ALL:-}" == *"UTF-8"* ]] || 
     [[ "${LC_CTYPE:-}" == *"UTF-8"* ]];
  then
    # Test if we can actually display Unicode
    if echo -e "\u2713" | grep -q "‚úì" 2>/dev/null; then
      SUPPORTS_UNICODE=true
    fi
  fi

  # Windows-specific checks
  if [[ "$OS_TYPE" == "windows" ]]; then
    if [[ -n "${WT_SESSION:-}" ]] || [[ -n "${MSYSTEM:-}" ]] || [[ -n "${WSL_DISTRO_NAME:-}" ]]; then
      SUPPORTS_UNICODE=true
      SUPPORTS_ANSI=true
    else
      SUPPORTS_UNICODE=false
      SUPPORTS_ANSI=false
    fi
  fi

  # Determine UI mode based on capabilities
  if [[ "$UI_MODE" == "auto" ]]; then
    if [[ "$SUPPORTS_UNICODE" == "true" && "$SUPPORTS_ANSI" == "true" && "$IS_INTERACTIVE" == "true" ]]; then
      UI_MODE="rich"
    elif [[ "$SUPPORTS_ANSI" == "true" ]]; then
      UI_MODE="minimal"
    else
      UI_MODE="ci"
    fi
  fi
}

detect_terminal_capabilities

# Visual elements and sprites
declare -A SPRITES
declare -A ICONS

init_visual_elements() {
  case "$UI_MODE" in
    rich)
      # Rich mode with Unicode sprites and icons
      SPRITES["rocket"]="üöÄ"
      SPRITES["package"]="üì¶"
      SPRITES["key"]="üîë"
      SPRITES["lock"]="üîí"
      SPRITES["shield"]="üõ°Ô∏è"
      SPRITES["cloud"]="‚òÅÔ∏è"
      SPRITES["gear"]="‚öôÔ∏è"
      SPRITES["sparkle"]="‚ú®"
      SPRITES["check"]="‚úÖ"
      SPRITES["cross"]="‚ùå"
      SPRITES["warning"]="‚ö†Ô∏è"
      SPRITES["info"]="‚ÑπÔ∏è"
      SPRITES["bulb"]="üí°"
      SPRITES["globe"]="üåç"
      SPRITES["bot"]="ü§ñ"
      
      ICONS["success"]="‚úì"
      ICONS["error"]="‚úó"
      ICONS["warning"]="‚ö†"
      ICONS["info"]="‚Ñπ"
      ICONS["arrow"]="‚Üí"
      ICONS["bullet"]="‚Ä¢"
      ICONS["progress"]="‚ñ∂"
      ;;
    minimal)
      # Minimal mode with basic Unicode
      SPRITES["rocket"]=">"
      SPRITES["package"]="[]"
      SPRITES["key"]="*"
      SPRITES["lock"]="#"
      SPRITES["shield"]="+"
      SPRITES["cloud"]="~"
      SPRITES["gear"]="@"
      SPRITES["sparkle"]="*"
      SPRITES["check"]="‚úì"
      SPRITES["cross"]="‚úó"
      SPRITES["warning"]="!"
      SPRITES["info"]="i"
      SPRITES["bulb"]="?"
      SPRITES["globe"]="o"
      SPRITES["bot"]="&"
      
      ICONS["success"]="‚úì"
      ICONS["error"]="‚úó"
      ICONS["warning"]="!"
      ICONS["info"]="i"
      ICONS["arrow"]=">"
      ICONS["bullet"]="-"
      ICONS["progress"]=">"
      ;;
    ci|*)
      # CI mode with ASCII only
      SPRITES["rocket"]="[RUN]"
      SPRITES["package"]="[PKG]"
      SPRITES["key"]="[KEY]"
      SPRITES["lock"]="[SEC]"
      SPRITES["shield"]="[PRO]"
      SPRITES["cloud"]="[API]"
      SPRITES["gear"]="[CFG]"
      SPRITES["sparkle"]="[NEW]"
      SPRITES["check"]="[OK]"
      SPRITES["cross"]="[ERR]"
      SPRITES["warning"]="[WRN]"
      SPRITES["info"]="[INF]"
      SPRITES["bulb"]="[TIP]"
      SPRITES["globe"]="[WEB]"
      SPRITES["bot"]="[BOT]"
      
      ICONS["success"]="[OK]"
      ICONS["error"]="[ERR]"
      ICONS["warning"]="[WRN]"
      ICONS["info"]="[INF]"
      ICONS["arrow"]="->"
      ICONS["bullet"]="*"
      ICONS["progress"]="=>"
      ;;
  esac
}

# Colors and formatting (cross-platform support)
init_colors() {
  if [[ "$UI_MODE" == "ci" ]] || [[ "$SUPPORTS_ANSI" != "true" ]]; then
    RED=""; GREEN=""; YELLOW=""; BLUE=""; PURPLE=""; CYAN=""; BOLD=""; DIM=""; UNDERLINE=""; NC=""
  elif [[ "$UI_MODE" == "rich" ]]; then
    # Enhanced colors for rich mode
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    PURPLE='\033[0;35m'
    CYAN='\033[0;36m'
    BOLD='\033[1m'
    DIM='\033[2m'
    UNDERLINE='\033[4m'
    NC='\033[0m'
  else
    # Basic colors for minimal mode
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    PURPLE=''
    CYAN=''
    BOLD='\033[1m'
    DIM='\033[2m'
    UNDERLINE=''
    NC='\033[0m'
  fi
}

init_colors
init_visual_elements

# Logging levels: 0=silent 1=error 2=warn 3=info 4=debug
LOG_LEVEL=${GREENER_LOG_LEVEL:-3}

log_debug() {
  [[ "$OUTPUT_MODE" == "json" ]] && return
  [[ ${LOG_LEVEL} -ge 4 ]] && echo -e "${DIM}‚Ä¶ $1${NC}"
}

log_info() {
  [[ "$OUTPUT_MODE" == "json" ]] && return
  if [[ ${LOG_LEVEL} -ge 3 ]]; then
    echo -e "${BLUE}${ICONS[info]}${NC} $1"
  fi
}

log_success() {
  [[ "$OUTPUT_MODE" == "json" ]] && return
  if [[ ${LOG_LEVEL} -ge 3 ]]; then
    echo -e "${GREEN}${ICONS[success]}${NC} $1"
  fi
}

log_warning() {
  [[ "$OUTPUT_MODE" == "json" ]] && return
  if [[ ${LOG_LEVEL} -ge 2 ]]; then
    echo -e "${YELLOW}${ICONS[warning]}${NC} $1"
  fi
}

log_error() {
  [[ "$OUTPUT_MODE" == "json" ]] && return
  # errors always print unless LOG_LEVEL=0
  if [[ ${LOG_LEVEL} -ge 1 ]]; then
    echo -e "${RED}${ICONS[error]}${NC} $1" >&2
  fi
}

log_header() {
  [[ "$OUTPUT_MODE" == "json" ]] && return
  [[ ${LOG_LEVEL} -ge 3 ]] && echo -e "\n${BOLD}$1${NC}"
}

# Spinner utilities with rich data
SPINNER_PID=""
SPINNER_START_TIME=""
SPINNER_MESSAGE=""
PROGRESS_DATA=""

# Rich spinner frames based on UI mode
get_spinner_frames() {
  case "$UI_MODE" in
    rich)
      # Multiple spinner styles for rich mode
      case "${SPINNER_STYLE:-dots}" in
        dots) echo "‚†ã ‚†ô ‚†π ‚†∏ ‚†º ‚†¥ ‚†¶ ‚†ß ‚†á ‚†è" ;;
        circle) echo "‚óê ‚óì ‚óë ‚óí" ;;
        bar) echo "‚ñâ‚ñä‚ñã‚ñå‚ñç‚ñé‚ñè‚ñé‚ñç‚ñå‚ñã‚ñä‚ñâ" ;;
        pulse) echo "‚£æ ‚£Ω ‚£ª ‚¢ø ‚°ø ‚£ü ‚£Ø ‚£∑" ;;
        globe) echo "üåç üåé üåè" ;;
        clock) echo "üïê üïë üïí üïì üïî üïï üïñ üïó üïò üïô üïö üïõ" ;;
        *) echo "‚†ã ‚†ô ‚†π ‚†∏ ‚†º ‚†¥ ‚†¶ ‚†ß ‚†á ‚†è" ;;
      esac
      ;;
    minimal)
      echo "‚†ã ‚†ô ‚†π ‚†∏ ‚†º ‚†¥ ‚†¶ ‚†ß ‚†á ‚†è"
      ;;
    ci|*)
      echo "- \\ | /"
      ;;
  esac
}

# Update progress data (for rich mode)
update_progress() {
  PROGRESS_DATA="$1"
}

spin_start() {
  local msg="$1"
  local style="${2:-dots}"
  [[ ${LOG_LEVEL} -lt 3 ]] && return 0
  [[ "$OUTPUT_MODE" == "json" ]] && return 0
  
  # CI mode: just print the message without animation
  if [[ "$UI_MODE" == "ci" ]]; then
    echo "${ICONS[progress]} $msg"
    return 0
  fi
  
  [[ ! -t 1 ]] && return 0
  
  SPINNER_MESSAGE="$msg"
  SPINNER_START_TIME=$(date +%s)
  SPINNER_STYLE="$style"
  PROGRESS_DATA=""
  
  local frames_str
  frames_str=$(get_spinner_frames)
  IFS=' ' read -ra frames <<< "$frames_str"
  
  local i=0
  {
    while true; do
      local elapsed_time=""
      if [[ "$UI_MODE" == "rich" ]] && [[ -n "$SPINNER_START_TIME" ]]; then
        local current_time
        current_time=$(date +%s)
        local elapsed=$((current_time - SPINNER_START_TIME))
        if [[ $elapsed -ge 2 ]]; then
          elapsed_time=" ${DIM}[${elapsed}s]${NC}"
        fi
      fi
      
      local progress_indicator=""
      if [[ -n "$PROGRESS_DATA" ]]; then
        progress_indicator=" ${CYAN}${PROGRESS_DATA}${NC}"
      fi
      
      # Clear line and print spinner with optional data
      printf "\r\033[K${BLUE}%s${NC} %s%s%s" "${frames[i]}" "${SPINNER_MESSAGE}" "${progress_indicator}" "${elapsed_time}"
      
      i=$(( (i+1) % ${#frames[@]} ))
      sleep 0.1
    done
  } &
  SPINNER_PID=$!
}

spin_stop() {
  local status="$1" # 0=success else error
  local msg="$2"
  local extra_info="${3:-}"
  
  [[ -n "${SPINNER_PID}" ]] && kill "${SPINNER_PID}" >/dev/null 2>&1 || true
  SPINNER_PID=""
  
  # CI mode
  if [[ "$UI_MODE" == "ci" ]]; then
    if [[ ${LOG_LEVEL} -ge 3 ]]; then
      if [[ "$status" -eq 0 ]]; then
        echo "${ICONS[success]} $msg"
      else
        echo "${ICONS[error]} $msg" >&2
      fi
      [[ -n "$extra_info" ]] && echo "  $extra_info"
    fi
    return
  fi
  
  # Rich/minimal modes
  if [[ ${LOG_LEVEL} -ge 3 ]]; then
    local elapsed_str=""
    if [[ "$UI_MODE" == "rich" ]] && [[ -n "$SPINNER_START_TIME" ]]; then
      local end_time
      end_time=$(date +%s)
      local total_elapsed=$((end_time - SPINNER_START_TIME))
      if [[ $total_elapsed -ge 1 ]]; then
        elapsed_str=" ${DIM}(${total_elapsed}s)${NC}"
      fi
    fi
    
    # Clear line and print final status
    if [[ "$status" -eq 0 ]]; then
      printf "\r\033[K${GREEN}${ICONS[success]}${NC} %s%s\n" "$msg" "$elapsed_str"
      [[ -n "$extra_info" ]] && echo "  ${DIM}${extra_info}${NC}"
    else
      printf "\r\033[K${RED}${ICONS[error]}${NC} %s%s\n" "$msg" "$elapsed_str" >&2
      [[ -n "$extra_info" ]] && echo "  ${YELLOW}${extra_info}${NC}" >&2
    fi
  fi
  
  SPINNER_START_TIME=""
  SPINNER_MESSAGE=""
  PROGRESS_DATA=""
}

# Prompt utilities
prompt_yes_no() {
  local prompt="$1"; local default="$2" # y or n
  local choice
  while true; do
    if [[ "$default" == "y" ]]; then
      read -r -p "$prompt [Y/n]: " choice || return 1
      choice=${choice:-y}
    else
      read -r -p "$prompt [y/N]: " choice || return 1
      choice=${choice:-n}
    fi
    case "${choice}" in
      y|Y) return 0;;
      n|N) return 1;;
      *) log_warning "Please answer 'y' or 'n'." ;;
    esac
  done
}

# Validation
validate_repo() {
  local repo="$1"
  [[ "$repo" =~ ^[A-Za-z0-9._-]+/[A-Za-z0-9._-]+$ ]]
}

# Config handling
CONFIG_PATH=""
resolve_config_path() {
  local xdg="${XDG_CONFIG_HOME:-$HOME/.config}"
  for p in "${CONFIG_PATH}" "$xdg/greener/cli.conf" "$HOME/.greener/cli.conf"; do
    [[ -n "$p" && -f "$p" ]] && echo "$p" && return 0
  done
  return 1
}

apply_config_file() {
  local cfg
  if cfg=$(resolve_config_path); then
    log_debug "Loading config: $cfg"
    # shellcheck disable=SC1090
    while IFS='=' read -r key value; do
      [[ -z "$key" || "$key" =~ ^# ]] && continue
      key=$(echo "$key" | tr '[:upper:]' '[:lower:]')
      value="${value%\r}"
      case "$key" in
        worker_url) WORKER_URL="$value";;
        log_level) LOG_LEVEL="$value";;
        color)
          if [[ "$value" == "never" ]]; then NO_COLOR=1; fi
          ;;
        interactive)
          if [[ "$value" == "false" ]]; then DEFAULT_INTERACTIVE=false; fi
          ;;
      esac
    done < "$cfg"
  fi
}

# Graceful exit
cleanup() {
  [[ -n "${SPINNER_PID}" ]] && kill "${SPINNER_PID}" >/dev/null 2>&1 || true
}
trap cleanup EXIT INT TERM
# JSON helpers
is_json() { [[ "$OUTPUT_MODE" == "json" ]]; }

# Simple JSON construction using printf
json_escape() {
  local str="$1"
  str="${str//\\/\\\\}"
  str="${str//\"/\\\"}"
  str="${str//$'\n'/\\n}"
  str="${str//$'\r'/\\r}"
  str="${str//$'\t'/\\t}"
  echo "$str"
}

emit_json_repo_result() {
  local repo="$1"; local ok="$2"; local http="$3"; local secrets_str="$4"
  if is_json; then
    repo=$(json_escape "$repo")
    printf '{"time":%d,"type":"provision","repo":"%s","ok":%s,"http":%s,"secrets":%s}\n' \
      "$(date +%s)" "$repo" "$ok" "${http:-null}" "${secrets_str:-null}"
  fi
}

emit_json_summary() {
  local success="$1"; local total="$2"
  if is_json; then
    printf '{"time":%d,"type":"summary","success":%d,"total":%d}\n' \
      "$(date +%s)" "$success" "$total"
  fi
}

emit_json_status() {
  local http="$1"; local body="$2"
  if is_json; then
    body=$(json_escape "$body")
    printf '{"time":%d,"type":"status","http":%d,"body":"%s"}\n' \
      "$(date +%s)" "$http" "$body"
  fi
}


# Defaults that can be overridden by config/env/CLI
DEFAULT_INTERACTIVE=true
ASSUME_YES=false
OUTPUT_MODE=${OUTPUT_MODE:-pretty}  # pretty|json
DRY_RUN=false
COMMAND="provision"


# Check prerequisites
check_prerequisites() {
    if [[ "$UI_MODE" == "rich" ]]; then
        log_header "${SPRITES[gear]} Checking Prerequisites"
    else
        log_header "Checking Prerequisites"
    fi

    # GitHub CLI
    spin_start "Checking for GitHub CLI" "dots"
    sleep 0.3  # Brief delay for visual feedback
    if ! command -v gh &> /dev/null; then
        spin_stop 1 "GitHub CLI (gh) is not installed" "Install from: https://cli.github.com/"
        exit ${EXIT_PREREQ}
    fi
    spin_stop 0 "GitHub CLI found"

    # Authenticated?
    spin_start "Checking GitHub authentication" "dots"
    sleep 0.3
    if ! gh auth status &> /dev/null; then
        spin_stop 1 "Not authenticated with GitHub CLI" "Run: gh auth login"
        exit ${EXIT_AUTH}
    fi
    spin_stop 0 "GitHub CLI authenticated"
    
    # Display UI mode info in rich mode
    if [[ "$UI_MODE" == "rich" ]]; then
        log_info "UI Mode: ${CYAN}Rich${NC} (Unicode: ${GREEN}Yes${NC}, Colors: ${GREEN}Yes${NC}, Interactive: ${GREEN}Yes${NC})"
    elif [[ "$UI_MODE" == "minimal" ]]; then
        log_info "UI Mode: Minimal (Limited Unicode/Colors)"
    else
        log_info "UI Mode: CI (Plain ASCII)"
    fi
}

# Get user's repositories
get_repositories() {
    if [[ "$UI_MODE" == "rich" ]]; then
        log_header "${SPRITES[globe]} Fetching Your Repositories"
    else
        log_header "Fetching Your Repositories"
    fi

    spin_start "Loading repository list from GitHub" "globe"
    update_progress "[0/100]"
    
    local repos
    repos=$(gh repo list --limit 100 --json name,owner,isPrivate,pushedAt --jq '.[] | "\(.owner.login)/\(.name) (\(if .isPrivate then "private" else "public" end))"' | sort)
    
    local repo_count
    repo_count=$(echo "$repos" | wc -l | tr -d ' ')
    update_progress "[${repo_count}/100]"

    if [[ -z "$repos" ]]; then
        spin_stop 1 "No repositories found"
        exit 1
    fi
    
    spin_stop 0 "Found ${repo_count} repositories"
    echo "$repos"
}

# Interactive repository selection
select_repositories() {
    if [[ "$UI_MODE" == "rich" ]]; then
        log_header "${SPRITES[package]} Select Repositories to Provision"
    else
        log_header "Select Repositories to Provision"
    fi

    local repos
    repos=$(get_repositories)

    if [[ "$UI_MODE" == "rich" ]]; then
        echo -e "\n${BOLD}Available repositories:${NC}"
        echo "$repos" | nl -w2 -s'. ' | sed "s/^/  ${ICONS[bullet]} /"
    else
        echo "Available repositories:"
        echo "$repos" | nl -w2 -s'. '
    fi
    echo

    read -p "Enter repository numbers (comma-separated, or 'all'): " selection

    if [[ "$selection" == "all" ]]; then
        echo "$repos" | sed 's/ (.*//'
        return
    fi

    # Parse selected numbers
    local selected_repos=()
    IFS=',' read -ra NUMBERS <<< "$selection"
    for num in "${NUMBERS[@]}"; do
        num=$(echo "$num" | xargs) # trim whitespace
        if [[ "$num" =~ ^[0-9]+$ ]]; then
            local repo
            repo=$(echo "$repos" | sed -n "${num}p" | sed 's/ (.*//')
            if [[ -n "$repo" ]]; then
                selected_repos+=("$repo")
            else
                log_warning "Invalid selection: $num"
            fi
        else
            log_warning "Invalid input: $num"
        fi
    done

    if [[ ${#selected_repos[@]} -eq 0 ]]; then
        log_error "No valid repositories selected"
        exit 1
    fi

    printf '%s\n' "${selected_repos[@]}"
}

# Get GitHub token
get_github_token() {
    local token
    token=$(gh auth token)
    if [[ -z "$token" ]]; then
        log_error "Failed to get GitHub token"
        exit 1
    fi
    echo "$token"
}

# Make HTTP request using available tools
http_request() {
    local method="$1"
    local url="$2"
    local data="$3"
    local token="$4"
    
    # Try to use curl if available, otherwise fallback to wget or native methods
    if command -v curl &>/dev/null; then
        local response
        response=$(curl -s -w "\n%{http_code}" \
            -X "$method" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $token" \
            ${data:+-d "$data"} \
            "$url" 2>/dev/null)
        echo "$response"
    elif command -v wget &>/dev/null; then
        local tmpfile=$(mktemp)
        local http_code
        if [[ "$method" == "POST" ]]; then
            if wget -q --header="Content-Type: application/json" \
                --header="Authorization: Bearer $token" \
                --post-data="$data" \
                --server-response \
                -O "$tmpfile" \
                "$url" 2>&1 | grep "HTTP/" | tail -1 | awk '{print $2}' > "${tmpfile}.code"; then
                http_code=$(cat "${tmpfile}.code")
            else
                http_code="000"
            fi
        elif [[ "$method" == "GET" ]]; then
            if wget -q --header="Content-Type: application/json" \
                --header="Authorization: Bearer $token" \
                --server-response \
                -O "$tmpfile" \
                "$url" 2>&1 | grep "HTTP/" | tail -1 | awk '{print $2}' > "${tmpfile}.code"; then
                http_code=$(cat "${tmpfile}.code")
            else
                http_code="000"
            fi
        else
            log_error "wget fallback only supports GET and POST methods"
            rm -f "$tmpfile" "${tmpfile}.code"
            return 1
        fi
        cat "$tmpfile"
        echo "$http_code"
        rm -f "$tmpfile" "${tmpfile}.code"
    else
        # Fallback: use gh api for GitHub endpoints or basic HTTP with /dev/tcp
        log_error "No HTTP client available (curl or wget required)"
        return 1
    fi
}

# Parse JSON value using shell (handles string, boolean, number, and null values)
json_get() {
    local json="$1"
    local key="$2"
    # Try gh --jq if available for better parsing
    if command -v gh &>/dev/null; then
        echo "$json" | gh api --input - --jq ".$key // empty" 2>/dev/null || {
            # Fallback to regex for simple cases
            echo "$json" | sed -n "s/.*\"$key\"[[:space:]]*:[[:space:]]*\"\([^\"]*\)\".*/\1/p" ||
            echo "$json" | sed -n "s/.*\"$key\"[[:space:]]*:[[:space:]]*\([^,}]*\).*/\1/p" | tr -d ' '
        }
    else
        # First try quoted string values
        local result
        result=$(echo "$json" | sed -n "s/.*\"$key\"[[:space:]]*:[[:space:]]*\"\([^\"]*\)\".*/\1/p")
        if [[ -n "$result" ]]; then
            echo "$result"
        else
            # Try unquoted values (boolean, number, null)
            echo "$json" | sed -n "s/.*\"$key\"[[:space:]]*:[[:space:]]*\([^,}]*\).*/\1/p" | tr -d ' '
        fi
    fi
}

# Parse JSON array using shell (improved robustness)
json_get_array() {
    local json="$1"
    local key="$2"
    # Try gh --jq if available for better parsing
    if command -v gh &>/dev/null; then
        echo "$json" | gh api --input - --jq ".${key}[]? // empty" 2>/dev/null || {
            # Fallback to simple regex for basic arrays
            echo "$json" | sed -n "s/.*\"$key\"[[:space:]]*:[[:space:]]*\[\([^]]*\)\].*/\1/p" | tr ',' '\n' | tr -d '[]" ' | grep -v '^$'
        }
    else
        # Basic parsing for simple string arrays
        # This handles ["value1", "value2"] format
        local array_content
        array_content=$(echo "$json" | sed -n "s/.*\"$key\"[[:space:]]*:[[:space:]]*\[\([^]]*\)\].*/\1/p")
        if [[ -n "$array_content" ]]; then
            # Extract quoted strings from array
            echo "$array_content" | grep -o '"[^"]*"' | tr -d '"'
        fi
    fi
}

# Provision secrets for a repository
provision_repository() {
    local repo="$1"
    local token="$2"

    if ! validate_repo "$repo"; then
        log_error "Invalid repository format: '$repo' (expected owner/name)"
        emit_json_repo_result "$repo" false "0" "null"
        return 1
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        spin_start "[dry-run] Provisioning secrets for $repo" "dots"
        sleep 0.5
        spin_stop 0 "[dry-run] Would provision secrets for $repo"
        emit_json_repo_result "$repo" true "200" "[]"
        return 0
    fi

    local spinner_msg
    if [[ "$UI_MODE" == "rich" ]]; then
        spinner_msg="${SPRITES[key]} Provisioning secrets for ${BOLD}$repo${NC}"
    else
        spinner_msg="Provisioning secrets for $repo"
    fi
    spin_start "$spinner_msg" "pulse"
    update_progress "[Connecting]"

    update_progress "[Sending request]"
    local response
    response=$(http_request "POST" "$WORKER_URL/api/cli-provision" "{\"repository\": \"$repo\"}" "$token")
    update_progress "[Processing]"
    
    if [[ -z "$response" ]]; then
        spin_stop 1 "Network error while provisioning $repo"
        emit_json_repo_result "$repo" false "0" "null"
        return 1
    fi

    # Extract HTTP code (last line) and body (everything else)
    local http_code=$(echo "$response" | tail -1)
    local body=$(echo "$response" | sed '$d')

    case "$http_code" in
        200|201)
            # Try to parse secrets from response
            local secrets_list
            secrets_list=$(json_get_array "$body" "secrets")
            local secret_info=""
            if [[ -n "$secrets_list" ]]; then
                if [[ "$UI_MODE" == "rich" ]]; then
                    secret_info="${SPRITES[check]} Secrets: $secrets_list"
                else
                    secret_info="Secrets: $secrets_list"
                fi
            fi
            spin_stop 0 "Successfully provisioned secrets for $repo" "$secret_info"
            # Convert secrets_list to JSON array format
            local secrets_json="[]"
            if [[ -n "$secrets_list" ]]; then
                # Format as JSON array
                secrets_json="["
                local first=true
                while IFS= read -r secret; do
                    if [[ -n "$secret" ]]; then
                        [[ "$first" == "false" ]] && secrets_json="${secrets_json},"
                        secrets_json="${secrets_json}\"$(json_escape "$secret")\""
                        first=false
                    fi
                done <<< "$secrets_list"
                secrets_json="${secrets_json}]"
            fi
            emit_json_repo_result "$repo" true "$http_code" "$secrets_json"
            return 0
            ;;
        401)
            spin_stop 1 "Authentication failed for $repo"
            log_info "Tip: Re-authenticate with: gh auth login"
            emit_json_repo_result "$repo" false "$http_code" "null"
            return 1
            ;;
        403)
            spin_stop 1 "Access denied for $repo"
            log_info "Tip: Ensure you have admin access to the repository."
            emit_json_repo_result "$repo" false "$http_code" "null"
            return 1
            ;;
        404)
            spin_stop 1 "Repository not found: $repo"
            log_info "Tip: Verify the repository name and your access."
            emit_json_repo_result "$repo" false "$http_code" "null"
            return 1
            ;;
        429)
            spin_stop 1 "Rate limited by server"
            log_warning "Waiting 60 seconds before retrying $repo..."
            sleep 60
            provision_repository "$repo" "$token"
            ;;
        *)
            spin_stop 1 "Failed to provision $repo (HTTP $http_code)"
            if [[ -n "$body" ]]; then
                log_error "Response: $body"
            fi
            emit_json_repo_result "$repo" false "$http_code" "null"
            return 1
            ;;
    esac
}

# Main provisioning logic
provision_secrets() {
    local repositories=("$@")
    local token
    token=$(get_github_token)

    if [[ "$UI_MODE" == "rich" ]]; then
        log_header "${SPRITES[rocket]} Provisioning CI/CD Secrets"
        log_info "${SPRITES[cloud]} Worker URL: ${CYAN}$WORKER_URL${NC}"
        log_info "${SPRITES[package]} Repositories selected: ${BOLD}${#repositories[@]}${NC}"
    else
        log_header "Provisioning CI/CD Secrets"
        log_info "Worker URL: $WORKER_URL"
        log_info "Repositories selected: ${#repositories[@]}"
    fi

    # Show summary and confirm
    if [[ "${ASSUME_YES}" != "true" ]]; then
      echo
      echo "Repositories to provision:"
      for r in "${repositories[@]}"; do echo "  - $r"; done
      echo
      if ! prompt_yes_no "Proceed with provisioning?" y; then
        log_warning "Operation cancelled by user"
        exit ${EXIT_UNKNOWN}
      fi
    fi

    local success_count=0
    local total_count=${#repositories[@]}
    local processed=0

    for repo in "${repositories[@]}"; do
        processed=$((processed+1))
        log_info "(${processed}/${total_count}) Starting: $repo"
        if provision_repository "$repo" "$token"; then
            ((success_count++))
        fi
        echo
    done

    if [[ "$UI_MODE" == "rich" ]]; then
        log_header "${SPRITES[sparkle]} Provisioning Complete"
    else
        log_header "Provisioning Complete"
    fi
    
    if [[ "$UI_MODE" == "rich" ]]; then
        log_info "${SPRITES[check]} Successfully provisioned: ${GREEN}$success_count${NC}/${total_count} repositories"
    else
        log_info "Successfully provisioned: $success_count/$total_count repositories"
    fi

    emit_json_summary "$success_count" "$total_count"

    if [[ $success_count -lt $total_count ]]; then
        if [[ "$UI_MODE" == "rich" ]]; then
            log_warning "${SPRITES[warning]} Some repositories failed. Check permissions and repository access."
        else
            log_warning "Some repositories failed. Check permissions and repository access."
        fi
        exit ${EXIT_PARTIAL}
    fi

    if [[ "$UI_MODE" == "rich" ]]; then
        log_success "${SPRITES[rocket]} All repositories provisioned successfully! ${SPRITES[sparkle]}"
    else
        log_success "All repositories provisioned successfully!"
    fi
}
# OS info helper
os_name() {
  local u
  u=$(uname -s 2>/dev/null || echo "")
  case "$u" in
    Darwin) echo "macOS";;
    Linux) echo "Linux";;
    MINGW*|MSYS*|CYGWIN*) echo "Windows";;
    *) echo "$u";;
  esac
}

os_arch() {
  uname -m 2>/dev/null || echo ""
}

# Status command
cmd_status() {
  if [[ "$DRY_RUN" == "true" ]]; then
    log_info "[dry-run] Would GET $WORKER_URL/health"
    emit_json_status 200 '{"status":"ok","dryRun":true}'
    exit ${EXIT_OK}
  fi
  local resp rc=0
  resp=$(http_request "GET" "$WORKER_URL/health" "" "") || rc=$?
  if [[ $rc -ne 0 || -z "$resp" ]]; then
    log_error "Network error contacting health endpoint"
    emit_json_status 0 'null'
    exit ${EXIT_NETWORK}
  fi
  local body http
  body=$(echo "$resp" | sed '$d')
  http=$(echo "$resp" | tail -n1)
  if [[ "$http" == "200" ]]; then
    log_success "Worker is healthy"
    emit_json_status 200 "$body"
    exit ${EXIT_OK}
  else
    log_error "Worker health check failed (HTTP $http)"
    [[ -n "$body" ]] && log_error "Response: $body"
    emit_json_status "$http" "$body"
    exit ${EXIT_UNKNOWN}
  fi
}

# Config command
resolve_write_config_path() {
  if [[ -n "${CONFIG_PATH:-}" ]]; then echo "$CONFIG_PATH"; return; fi
  local xdg="${XDG_CONFIG_HOME:-$HOME/.config}"
  echo "$xdg/greener/cli.conf"
}

cmd_config() {
  local action="${1:-show}"; shift || true
  case "$action" in
    show)
      local path
      path=$(resolve_config_path || true)
      if [[ -n "$path" ]]; then
        log_info "Using config: $path"
        if is_json; then
          local content
          content=$(json_escape "$(cat "$path")")
          printf '{"path":"%s","content":"%s"}\n' "$(json_escape "$path")" "$content"
        else
          cat "$path"
        fi
      else
        log_warning "No config file found"
      fi
      ;;
    set)
      local key="${1:-}" value="${2:-}"
      if [[ -z "$key" || -z "$value" ]]; then
        log_error "Usage: ${CLI_NAME} config set <key> <value>"
        exit ${EXIT_BAD_ARGS}
      fi
      local path
      path=$(resolve_write_config_path)
      mkdir -p "$(dirname "$path")"
      # update or append
      if grep -qi "^$key=" "$path" 2>/dev/null; then
        # Cross-platform sed
        if [[ "$OS_TYPE" == "macos" ]]; then
          sed -i '' "s|^$key=.*|$key=$value|i" "$path"
        else
          sed -i "s|^$key=.*|$key=$value|i" "$path"
        fi
      else
        echo "$key=$value" >> "$path"
      fi
      log_success "Updated $key in $path"
      ;;
    *)
      log_error "Unknown config action: $action"
      exit ${EXIT_BAD_ARGS}
      ;;
  esac
}

# Remote exec command (requires worker support)
cmd_remote_exec() {
  local cmd_str="$*"
  if [[ -z "$cmd_str" ]]; then
    log_error "Usage: ${CLI_NAME} remote-exec -- <command and args>"
    exit ${EXIT_BAD_ARGS}
  fi
  local os arch
  os=$(os_name); arch=$(os_arch)
  if [[ "$DRY_RUN" == "true" ]]; then
    log_info "[dry-run] Would POST $WORKER_URL/api/exec with command: $cmd_str"
    emit_json_status 200 "{\"ok\":true,\"dryRun\":true,\"os\":\"$os\",\"arch\":\"$arch\"}"
    exit ${EXIT_OK}
  fi
  local resp rc=0
  local json_data="{\"command\":\"$(json_escape "$cmd_str")\",\"os\":\"$(json_escape "$os")\",\"arch\":\"$(json_escape "$arch")\"}"
  resp=$(http_request "POST" "$WORKER_URL/api/exec" "$json_data" "") || rc=$?
  if [[ $rc -ne 0 || -z "$resp" ]]; then
    log_error "Network error calling remote exec"
    emit_json_status 0 'null'
    exit ${EXIT_NETWORK}
  fi
  local body http
  body=$(echo "$resp" | sed '$d')
  http=$(echo "$resp" | tail -n1)
  if [[ "$http" == "200" ]]; then
    log_success "Remote execution succeeded"
    emit_json_status 200 "$body"
    exit ${EXIT_OK}
  else
    log_error "Remote execution failed (HTTP $http)"
    [[ -n "$body" ]] && log_error "Response: $body"
    emit_json_status "$http" "$body"
    exit ${EXIT_UNKNOWN}
  fi
}


# Usage information
show_usage() {
    cat << EOF
Greener CI/CD CLI

USAGE:
    ${CLI_NAME} [global options] [command] [args]

COMMANDS:
    provision                 Provision secrets (default)
    status                    Check worker health
    config [show|set]         Manage CLI configuration
    remote-exec -- CMD ARGS   Execute a command remotely via the worker (experimental)

GLOBAL OPTIONS:
    -r, --repos REPO1,REPO2     Comma-separated list (owner/name)
    -i, --interactive           Interactive repository selection (default)
    -n, --non-interactive       Disable interactive prompts
    -y, --yes                   Assume "yes" to confirmations
    -w, --worker-url URL        Custom worker URL (default: $WORKER_URL)
    -c, --config PATH           Load configuration file
        --dry-run               Preview actions without network calls
    -o, --output MODE           Output: pretty|json (default: pretty)
        --ui MODE               UI mode: auto|rich|minimal|ci (default: auto)
    -v, --verbose               Increase verbosity (repeatable)
    -q, --quiet                 Reduce verbosity (errors only)
        --version               Show version information
    -h, --help                  Show this help message

CONFIG FILE (~/.config/greener/cli.conf):
    worker_url=...
    log_level=0|1|2|3|4
    interactive=true|false
    color=never

EXAMPLES:
    ${CLI_NAME}                                        # Interactive provisioning
    ${CLI_NAME} -r myorg/repo1,myorg/repo2 -y -n       # Non-interactive, auto-confirm
    ${CLI_NAME} -w https://my-worker.dev provision     # Explicit subcommand
    ${CLI_NAME} status                                 # Check worker health
    ${CLI_NAME} --dry-run -o json -r my/repo           # Dry-run with JSON output
    ${CLI_NAME} config show                            # Show effective config
    ${CLI_NAME} config set worker_url https://...      # Persist worker URL
    ${CLI_NAME} remote-exec -- echo hello              # Execute remotely (if enabled)

SETUP:
    1. Install GitHub CLI: https://cli.github.com/
    2. Authenticate: gh auth login

This tool provisions the following secrets per repository:
    GREENER_CI_KEY, GREENER_CI_SECRET, GREENER_API_TOKEN, GREENER_APP_ID, GREENER_INSTALLATION_ID

Docs: ${HOMEPAGE}
EOF
}

# Parse command line arguments
main() {
    local repos_arg=""
    local interactive=${DEFAULT_INTERACTIVE}


    # Load default config if present
    apply_config_file || true

    while [[ $# -gt 0 ]]; do
        case $1 in
            -r|--repos)
                repos_arg="$2"
                interactive=false
                shift 2
                ;;
            -i|--interactive)
                interactive=true
                shift
                ;;
            -n|--non-interactive)
                interactive=false
                shift
                ;;
            -c|--config)
                CONFIG_PATH="$2"
                shift 2
                apply_config_file || true
                ;;

            -y|--yes)
                ASSUME_YES=true
                shift
                ;;

            -w|--worker-url)
                WORKER_URL="$2"
                shift 2
                ;;
            -v|--verbose)
                LOG_LEVEL=$(( LOG_LEVEL + 1 ))
                [[ ${LOG_LEVEL} -gt 4 ]] && LOG_LEVEL=4
                shift
                ;;
            -q|--quiet)
                LOG_LEVEL=1
                shift
                ;;
            --version)
                echo "${CLI_NAME} v${VERSION}"
                exit ${EXIT_OK}
                ;;

            -h|--help)
                show_usage
                exit ${EXIT_OK}
                ;;
            *)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done

    # Header
    log_header "Greener CI/CD Secret Provisioning (v${VERSION})"

    # Check prerequisites
    check_prerequisites

    # Get repositories to provision
    local repositories=()
    if [[ "$interactive" == "true" ]]; then
        readarray -t repositories < <(select_repositories)
    else
        if [[ -z "$repos_arg" ]]; then
            log_error "Repository list required when not in interactive mode"
            show_usage
            exit ${EXIT_BAD_ARGS}
        fi
        IFS=',' read -ra repositories <<< "$repos_arg"
    fi

    if [[ ${#repositories[@]} -eq 0 ]]; then
        log_error "No repositories selected"
        exit ${EXIT_BAD_ARGS}
    fi

    # Trim and validate list
    local valid_repos=()
    for r in "${repositories[@]}"; do
        r="$(echo "$r" | xargs)"
        if validate_repo "$r"; then
            valid_repos+=("$r")
        else
            log_warning "Skipping invalid repository: $r"
        fi
    done

    if [[ ${#valid_repos[@]} -eq 0 ]]; then
        log_error "No valid repositories provided"
        exit ${EXIT_BAD_ARGS}
    fi


    # Provision secrets
    provision_secrets "${valid_repos[@]}"
}

# New main with subcommands and output/dry-run support (overrides previous)
main() {
    local repos_arg=""
    local interactive=${DEFAULT_INTERACTIVE}

    apply_config_file || true

    # Detect subcommand first
    if [[ $# -gt 0 ]]; then
      case "$1" in
        provision|status|config|remote-exec)
          COMMAND="$1"; shift ;;
      esac
    fi

    # Parse global options
    while [[ $# -gt 0 ]]; do
      case $1 in
        -r|--repos) repos_arg="$2"; interactive=false; shift 2;;
        -i|--interactive) interactive=true; shift;;
        -n|--non-interactive) interactive=false; shift;;
        -c|--config) CONFIG_PATH="$2"; shift 2; apply_config_file || true;;
        -y|--yes) ASSUME_YES=true; shift;;
        -w|--worker-url) WORKER_URL="$2"; shift 2;;
        --dry-run) DRY_RUN=true; shift;;
        -o|--output) OUTPUT_MODE="$2"; shift 2;;
        --ui)
            UI_MODE="$2"
            case "$UI_MODE" in
                auto|rich|minimal|ci) ;;
                *) log_error "Invalid UI mode: $2 (options: auto|rich|minimal|ci)"; exit ${EXIT_BAD_ARGS};;
            esac
            # Re-detect capabilities and reinitialize
            detect_terminal_capabilities
            init_colors
            init_visual_elements
            shift 2
            ;;
        -v|--verbose) LOG_LEVEL=$(( LOG_LEVEL + 1 )); [[ ${LOG_LEVEL} -gt 4 ]] && LOG_LEVEL=4; shift;;
        -q|--quiet) LOG_LEVEL=1; shift;;
        --version) echo "${CLI_NAME} v${VERSION}"; exit ${EXIT_OK};;
        -h|--help) show_usage; exit ${EXIT_OK};;
        --) shift; break;;
        *)
          if [[ "$COMMAND" == "remote-exec" || "$COMMAND" == "config" ]]; then
            break
          fi
          log_error "Unknown option: $1"; show_usage; exit ${EXIT_BAD_ARGS};;
      esac
    done

    case "$COMMAND" in
      status) cmd_status; return;;
      config) cmd_config "$@"; return;;
      remote-exec) cmd_remote_exec "$@"; return;;
      provision|*) :;;
    esac

    # Provision default flow
    # Display header based on UI mode
    if [[ "$UI_MODE" == "rich" ]]; then
        log_header "${SPRITES[rocket]} Greener CI/CD Secret Provisioning ${SPRITES[shield]} (v${VERSION})"
    else
        log_header "Greener CI/CD Secret Provisioning (v${VERSION})"
    fi
    check_prerequisites

    local repositories=()
    if [[ "$interactive" == "true" ]]; then
      readarray -t repositories < <(select_repositories)
    else
      if [[ -z "$repos_arg" ]]; then
        log_error "Repository list required when not in interactive mode"; show_usage; exit ${EXIT_BAD_ARGS}
      fi
      IFS=',' read -ra repositories <<< "$repos_arg"
    fi

    if [[ ${#repositories[@]} -eq 0 ]]; then
      log_error "No repositories selected"; exit ${EXIT_BAD_ARGS}
    fi

    local valid_repos=()
    for r in "${repositories[@]}"; do
      r="$(echo "$r" | xargs)"
      if validate_repo "$r"; then valid_repos+=("$r"); else log_warning "Skipping invalid repository: $r"; fi
    done
    if [[ ${#valid_repos[@]} -eq 0 ]]; then log_error "No valid repositories provided"; exit ${EXIT_BAD_ARGS}; fi

    provision_secrets "${valid_repos[@]}"
}

# Run main function
main "$@"