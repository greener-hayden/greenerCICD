name: Sync GitHub App Secrets (Optimized)

# Skip on [skip ci] commits

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * 0'  # Weekly on Sunday at midnight
  push:
    paths:
      - '.github/app-installations.json'

permissions:
  contents: write

concurrency:
  group: sync-secrets
  cancel-in-progress: false

jobs:
  # Fast pre-check to determine if sync is needed
  check-sync:
    if: ${{ !contains(github.event.head_commit.message, '[skip ci]') }}
    runs-on: ubuntu-22.04
    timeout-minutes: 1
    outputs:
      should-sync: ${{ steps.check.outputs.should-sync }}
      repo-matrix: ${{ steps.check.outputs.matrix }}
      repo-count: ${{ steps.check.outputs.count }}

    steps:
      - name: Generate app token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.APP_ID || secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Check and prepare sync
        id: check
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          # Get all installed repositories in parallel
          REPOS=$(gh api "/app/installations" --paginate --jq '.[].id' | \
            xargs -P10 -I{} gh api "/app/installations/{}/repositories" --jq '.repositories[].full_name' | \
            sort -u)

          REPO_COUNT=$(echo "$REPOS" | wc -l)
          echo "Found $REPO_COUNT repositories"

          if [ "$REPO_COUNT" -eq 0 ]; then
            echo "should-sync=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Create matrix for parallel processing (max 10 per batch)
          BATCH_SIZE=10
          MATRIX_JSON="["
          BATCH_NUM=0
          COUNT=0
          BATCH_REPOS=""

          for REPO in $REPOS; do
            # Add comma before repo name if not first repo in batch
            if [ $COUNT -gt 0 ]; then
              BATCH_REPOS="${BATCH_REPOS},"
            fi
            BATCH_REPOS="${BATCH_REPOS}${REPO}"
            COUNT=$((COUNT + 1))

            # Close batch when reaching batch size
            if [ $COUNT -eq $BATCH_SIZE ]; then
              # Add comma before batch if not first batch
              if [ $BATCH_NUM -gt 0 ]; then
                MATRIX_JSON="${MATRIX_JSON},"
              fi
              MATRIX_JSON="${MATRIX_JSON}{\"batch\":$BATCH_NUM,\"repos\":\"${BATCH_REPOS}\"}"
              BATCH_NUM=$((BATCH_NUM + 1))
              BATCH_REPOS=""
              COUNT=0
            fi
          done

          # Add remaining repos if any
          if [ $COUNT -gt 0 ]; then
            # Add comma before batch if not first batch
            if [ $BATCH_NUM -gt 0 ]; then
              MATRIX_JSON="${MATRIX_JSON},"
            fi
            MATRIX_JSON="${MATRIX_JSON}{\"batch\":$BATCH_NUM,\"repos\":\"${BATCH_REPOS}\"}"
          fi

          MATRIX_JSON="${MATRIX_JSON}]"

          echo "should-sync=true" >> $GITHUB_OUTPUT
          echo "matrix=${MATRIX_JSON}" >> $GITHUB_OUTPUT
          echo "count=$REPO_COUNT" >> $GITHUB_OUTPUT

  # Parallel secret synchronization
  sync-batch:
    needs: check-sync
    if: needs.check-sync.outputs.should-sync == 'true'
    runs-on: ubuntu-22.04
    timeout-minutes: 1
    strategy:
      matrix:
        batch: ${{ fromJson(needs.check-sync.outputs.repo-matrix) }}
      max-parallel: 10
      fail-fast: false

    steps:
      - name: Checkout sparse
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/app-installations.json
          sparse-checkout-cone-mode: false
          fetch-depth: 1

      - name: Cache tools
        uses: actions/cache@v4
        with:
          path: |
            ~/.local/bin
          key: tools-${{ runner.os }}-${{ hashFiles('.github/workflows/*.yml') }}
          restore-keys: tools-${{ runner.os }}-

      - name: Generate app token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.APP_ID || secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Sync batch secrets
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          APP_ID: ${{ secrets.APP_ID }}
          REPOS: ${{ matrix.batch.repos }}
        run: |
          echo "ðŸ”„ Processing batch ${{ matrix.batch.batch }}"

          # Load installations file
          INST_FILE=".github/app-installations.json"
          [ ! -f "$INST_FILE" ] && echo '{"repositories":{}}' > "$INST_FILE"

          # Process repos in this batch
          IFS=',' read -ra REPO_ARRAY <<< "$REPOS"
          for REPO in "${REPO_ARRAY[@]}"; do
            echo "ðŸ“¦ $REPO"

            # Fast check if already configured
            if gh api "/repos/$REPO/actions/secrets" --jq '.secrets[].name' 2>/dev/null | grep -q "GREENER_CI_KEY"; then
              # Check age for rotation
              LAST_UPDATE=$(jq -r ".repositories[\"$REPO\"].updated // \"1970-01-01\"" "$INST_FILE")
              DAYS_OLD=$(( ($(date +%s) - $(date -d "$LAST_UPDATE" +%s)) / 86400 ))

              if [ $DAYS_OLD -lt 30 ]; then
                echo "  âœ“ Up to date ($DAYS_OLD days)"
                continue
              fi
              echo "  ðŸ”„ Rotating (${DAYS_OLD}d old)"
            else
              echo "  ðŸ†• First setup"
            fi

            # Generate secrets
            CI_KEY=$(openssl rand -hex 32)
            CI_SECRET=$(openssl rand -hex 64)
            API_TOKEN=$(openssl rand -hex 32)
            INST_ID=$(gh api "/repos/$REPO/installation" --jq '.id')

            # Batch set all secrets in parallel
            (
              echo "$CI_KEY" | gh secret set GREENER_CI_KEY --repo "$REPO" &
              echo "$CI_SECRET" | gh secret set GREENER_CI_SECRET --repo "$REPO" &
              echo "$API_TOKEN" | gh secret set GREENER_API_TOKEN --repo "$REPO" &
              echo "$APP_ID" | gh secret set GREENER_APP_ID --repo "$REPO" &
              echo "$INST_ID" | gh secret set GREENER_INSTALLATION_ID --repo "$REPO" &
              wait
            ) 2>/dev/null

            # Update tracking
            jq --arg r "$REPO" --arg d "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              '.repositories[$r] = {"updated": $d}' "$INST_FILE" > tmp.json && mv tmp.json "$INST_FILE"

            echo "  âœ… Configured"
          done

  # Final consolidation and commit
  finalize:
    needs: [check-sync, sync-batch]
    if: |
      always() &&
      needs.check-sync.outputs.should-sync == 'true' &&
      !contains(github.event.head_commit.message, '[skip ci]')
    runs-on: ubuntu-22.04
    timeout-minutes: 1

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update tracking file
        run: |
          jq '.synced = "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"' \
            .github/app-installations.json > tmp.json && mv tmp.json .github/app-installations.json

      - name: Commit if changed
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add .github/app-installations.json
          git diff --staged --quiet || git commit -m "ðŸ”„ Update sync tracking [skip ci]"
          git push || true

      - name: Summary
        run: |
          echo "### âœ… Secret Sync Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Repositories**: ${{ needs.check-sync.outputs.repo-count }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Time**: ~$(( $SECONDS / 60 ))m $(( $SECONDS % 60 ))s" >> $GITHUB_STEP_SUMMARY
